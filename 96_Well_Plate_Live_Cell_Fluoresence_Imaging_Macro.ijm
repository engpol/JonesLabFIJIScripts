//MACRO FOR ANALYSING CADDIS/CALCIUM IMAGING DATA FEATURING FLUORESCENT SOMA IN 96 WELL PLATE
//GENERAL PRINCIPLE:
//1: DEFINE HOW MANY WELLS, FOV AND TIME POINTS PRESENT IN EACH WELL
//1: IMPORT STACK OF NxN GRID MICROSCOPY IMAGES
//2: COMPUTE THE BASIC PROFILE BASED ON SUBSTACK OF IMAGES - TO AID WITH PROCESSING SPEED - THANKS IONA
//3: RUN BASIC PROFILE ON ORIGINAL STACK TO PERFORM BACKGROUND CORRECTION
//4: DEINTERLEAVE GRID STACK INTO X DIFFERENT STACKS BASED ON NUMBER OF FOV + WELLS + TIME
//5: SAVE EACH DEINTERLEAVED STACK INTO ITS OWN FOLDER WITHIN EXPERIMENT FOLDER; CLOSE ALL IMAGES
//6: CREATE A FOR LOOP TO IMPORT ALL FOVS AND FOR EACH:
//   - RUN STARDIST TO CREATE ROIS AROUND FLUORESCENT CELLS (SETTINGS TO BE CALIBRATED TO EXCLUDE TOO LARGE/SMALL CELLS) - USE FINAL IMAGE OF STACK TO GENERATE (ADD AS PARAMETER), WILL HAVE THE GREATEST CONTRAST
//   - DO A NESTED FOR LOOP TO LOOP THROUGH ROIS GENERATED BY STARDIST AND FOR EACH:
//             -TURN INTO A MASK BY CREATING A HYPERSTACK OF EQUAL DIMENSIONS, CLICKING FILL, DIVIDING BY MAX PIX INTENSITY AND MULTIPLYING BY ORIGINAL STACK
//             -LOOPING THROUGH ALL SLICES, AND TAKING AVERAGE MEASUREMENT
// 


//- - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - -- - - -- -- - - - - - -- -- - - - - - -- -- - -
//Global Parameters 
//- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - -- - - - -- -- - - - - - --
#@ File(label="Experiment Folder", value = "C:/", style="directory") exfolder
#@ Integer (label="Number of Timepoints", value = 16, style="spinner", min = 1, max = 1000) timepoint_number
#@ Integer (label="Number of FOVs", value = 49, style="spinner", min = 1, max = 99) FOV_number
#@ Integer (label="Number of Wells", value = 49, style="spinner", min = 1, max = 99) well_number
#@ boolean (label = "Drift Present?") Drift_check
#@ boolean (label = "Multiple Timepoints? (If not, please put no of timepoints as 2)") timepoint_check

run("Fresh Start"); //ALWAYS INCLUDE
setBatchMode(true); //"TRUE" FOR FASTER PROCESSING
run("Set Measurements...", "area mean display redirect=None decimal=2"); //Having the right measurements for collecting data - change here if you want to collect any more data

//- - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - -- - - -- -- - - - - - -- -- - - - - - -- -- - -

function ImageFilesOnlyArray (arr) {
	//pass array from getFileList through this e.g. NEWARRAY = ImageFilesOnlyArray(NEWARRAY);
	setOption("ExpandableArrays", true);
	f=0;
	files = newArray;
	for (i = 0; i < arr.length; i++) {
		if(endsWith(arr[i], ".tif") || endsWith(arr[i], ".nd2") || endsWith(arr[i], ".LSM") || endsWith(arr[i], ".czi") || endsWith(arr[i], ".jpg") ) {   //if it's a tiff image add it to the new array
			files[f] = arr[i];
			f = f+1;
		}
	}
	arr = files;
	arr = Array.sort(arr);
	return arr;
}

//- - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- -- - -- - - -- -- - - - - - -- -- - - - - - -- -- - -
// - VARIABLES 
//- - - -- -- - - - - - -- -- - - - - - -- -- - - - - - -- - - - -- -- - - - - - -- - - - -- -- - - - - - -- - - - -- -- - - - - - --

length_filelist = getFileList(exfolder);
filelist_Length = lengthOf(length_filelist)

// - - - -- -- - - - - - -- - - - -- -- - - - - - -- - - - -- -- - - - - - -- - - - -- -- - - - - - --  - - - -- -- - - - - - --
// CODE 
// - - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --
// BACKGROUND SUBTRACTION AND SPLITTING STACK INTO SEPERATE FOVS AND DEALING WITH 1 TIMEPOINT BULLSHITTERY
// - - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --

File.openSequence(exfolder,"step=1"); //Import the Experiment Image Stack
rename("expt"); //rename to call easier
selectImage("expt"); //select image
if (timepoint_check == false) {  //Super messy workaround for if only have 1 timepoint. Double up stack to artificially create a second time point - it will be removed in R script anyway
infoArraydouble = newArray(); //This and the following code has to be done because interleave does not transfer image metadata into the combined stack
for (i = 0; i < nSlices; i++) {
testArray = newArray(); //make empty array
setSlice(i+1); //Set to acrive slice
testArray[0] = getMetadata("Info"); //get image label from active slice
infoArraydouble = Array.concat(infoArraydouble, testArray); //Add twice to empty array, as combined stack will have each image added twice, i.e. 1,1,2,2,3,3 etc. 
infoArraydouble = Array.concat(infoArraydouble, testArray);
}
run("Duplicate...", "title=DupliStack duplicate"); //duplicate stack
run("Interleave", "stack_1=expt stack_2=DupliStack"); //re-interleave
selectImage("Combined Stacks");
//ImageJ macro has essentially no easy way to extract strings from an array - REALLY ANNOYING!!!!! - workaround I've found is to create a table, set a column to the values of my array 
//And then use Table.getstring to extract the string from the index position of the table column. Really really stupid but it will have to do
Table.create("TEXT"); //Create table 
Table.setColumn("METAID", infoArraydouble); //Set table column to my array
for (i = 0; i < nSlices; i++) {
metaidstring = Table.getString("METAID", i); //Get i index string
selectImage("Combined Stacks");
setSlice(i+1);
setMetadata("Label", metaidstring); //Set image label to string
}
selectImage("Combined Stacks");
run("Slice Keeper", "first=1 last="+FOV_number*timepoint_number*well_number+" increment="+(FOV_number*timepoint_number-1)+""); //Ionas idea, make a subset of the stack to compute the BASIC shading profile on, use on full stack after compute - saves run time. Use a smaller increment to timepoint so as to not use only the first frame from each FOV
selectImage("Combined Stacks kept stack");
run("BaSiC ", "processing_stack=[Combined Stacks kept stack] flat-field=None dark-field=None shading_estimation=[Estimate shading profiles] shading_model=[Estimate flat-field only (ignore dark-field)] setting_regularisationparametes=Manual temporal_drift=Ignore correction_options=[Compute shading only] lambda_flat=4 lambda_dark=0.50"); //Compute shading profile based on the stack subset, you will use this to generate the flat field which will then be ran on the entire experiment stack
selectImage("Flat-field:Combined Stacks kept stack");
run("BaSiC ", "processing_stack=[Combined Stacks] flat-field=[Flat-field:Combined Stacks kept stack] dark-field=None shading_estimation=[Skip estimation and use predefined shading profiles] shading_model=[Estimate flat-field only (ignore dark-field)] setting_regularisationparametes=Automatic temporal_drift=[Replace with zero] correction_options=[Compute shading and correct images] lambda_flat=0.50 lambda_dark=0.50"); //Compute shading profile for entire stack
selectImage("Corrected:Combined Stacks");
}else {
run("Slice Keeper", "first=1 last="+FOV_number*timepoint_number*well_number+" increment="+(FOV_number*timepoint_number-1)+""); //Ionas idea, make a subset of the stack to compute the BASIC shading profile on, use on full stack after compute - saves run time. Use a smaller increment to timepoint so as to not use only the first frame from each FOV
selectImage("expt kept stack");
run("BaSiC ", "processing_stack=[expt kept stack] flat-field=None dark-field=None shading_estimation=[Estimate shading profiles] shading_model=[Estimate flat-field only (ignore dark-field)] setting_regularisationparametes=Manual temporal_drift=Ignore correction_options=[Compute shading only] lambda_flat=4 lambda_dark=0.50"); //Compute shading profile based on the stack subset, you will use this to generate the flat field which will then be ran on the entire experiment stack
selectImage("Flat-field:expt kept stack");
run("BaSiC ", "processing_stack=[expt] flat-field=[Flat-field:expt kept stack] dark-field=None shading_estimation=[Skip estimation and use predefined shading profiles] shading_model=[Estimate flat-field only (ignore dark-field)] setting_regularisationparametes=Automatic temporal_drift=[Replace with zero] correction_options=[Compute shading and correct images] lambda_flat=0.50 lambda_dark=0.50"); //Compute shading profile for entire stack
selectImage("Corrected:expt");
}
close("\\Others");
run("Add...", "value=1 stack"); //Add 1 to all pixel values as bg has been set to 0 and want to avoid diving by 0 later when calculating dF/F0
rename("Corrected_Flo_Image");
selectImage("Corrected_Flo_Image");
run("Stack Splitter", "number="+well_number); //Split image stack according to number of wells
File.mkdir(exfolder + File.separator + "Individual_Well"+""); //Make folder to save stacks in

// - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - 
//FOR LOOP TO FURTHER SPLIT THE STACKS BASED ON FOV AND SAVE IN EACH FOLDER - If you have more than 99 Wells/FOVs you will need to update this/find a general solution however for now i cba
// - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - - - - - - - - - - - - -- - - - - - - - - - - - - - - 

for (i = 0; i < well_number; i++) { //Loop through each split stack
File.mkdir(exfolder + File.separator + "Individual_Well" + File.separator + "Well_Number_"+(i+1)+"");  //Make a folder for the active Well
if (i < 9){ //Has to be done as for i less than 10 as i will be single digit- i.e. 0001 vs 0010
selectImage("stk_000"+(i+1)+"_Corrected_Flo_Image");
rename("Stack_Split_Image_"+(i+1)+"");
run("Stack Splitter", "number="+FOV_number); //Split the stack further based on FOV_number
}else {
selectImage("stk_00"+(i+1)+"_Corrected_Flo_Image");
rename("Stack_Split_Image_"+(i+1)+"");
run("Stack Splitter", "number="+FOV_number);
}
for (j = 0; j < FOV_number; j++) { //Nested for loop
File.mkdir(exfolder + File.separator + "Individual_Well" + File.separator + "Well_Number_"+(i+1)+ File.separator + "FOV_Number_"+(j+1)+""); //Make a folder for the active Well
if (j < 9){
selectImage("stk_000"+(j+1)+"_Stack_Split_Image_"+(i+1)+"");
run("Image Sequence... ", "dir="+exfolder + File.separator + "Individual_Well" + File.separator + "Well_Number_"+(i+1)+ File.separator + "FOV_Number_"+(j+1)+""+" format=TIFF");
}else {
selectImage("stk_00"+(j+1)+"_Stack_Split_Image_"+(i+1)+"");
run("Image Sequence... ", "dir="+exfolder + File.separator + "Individual_Well" + File.separator + "Well_Number_"+(i+1)+ File.separator + "FOV_Number_"+(j+1)+""+" format=TIFF");
}
}
}
close("*"); //Close all open image windows



// - - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --
// FOR EACH FOV, OPEN WELL
//CORRECT FOR DRIFT
//RUN STAR DIST, MAKE MASTK
//MULTIPLY BY INSTENSITY
//TAKE MEASUREMENT OF AVERAGE INSTENSITY - DO NOT REMOVE, KEEP ADDING ONTO COLUMN
//SAVE INTO FOLDER OF EACH WELL - ONLY AFTER ALL WELLS HAVE TAKEN MEASUREMENTS - SHOULD BE EACH COLUMN COUNTS MEASUREMENTS FOR EACH TIMEPOINT
//- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --- - - -- -- - - - - - --


File.mkdir(exfolder + File.separator + "Well_Averages"+"");
for (i = 0; i < well_number; i++) {
   for (j = 0; j < FOV_number; j++) {
	    File.openSequence(exfolder + File.separator + "Individual_Well" + File.separator + "Well_Number_"+(i+1)+ File.separator + "FOV_Number_" +(j+1)+"","step=1");
	     if (Drift_check == true) {
	run("Linear Stack Alignment with SIFT", "initial_gaussian_blur=1.60 steps_per_scale_octave=3 minimum_image_size=64 maximum_image_size=1024 feature_descriptor_size=10 feature_descriptor_orientation_bins=8 closest/next_closest_ratio=0.92 maximal_alignment_error=25 inlier_ratio=0.05 expected_transformation=Translation interpolate");
    selectImage("Aligned "+timepoint_number + " of " + timepoint_number);
    }   
	    run("Z Project...", "projection=[Max Intensity]"); //find average area of cell containting regions
	    if (Drift_check == true) {
    	selectImage("MAX_Aligned "+timepoint_number + " of " + timepoint_number);
    }
    else {
	    selectImage("MAX_FOV_Number_"+(j+1)+"");//select cell containging regions
    }
        pixelheight = getHeight();
        rename("TEST");
	    run("Command From Macro", "command=[de.csbdresden.stardist.StarDist2D], args=['input':'TEST', 'modelChoice':'Versatile (fluorescent nuclei)', 'normalizeInput':'true', 'percentileBottom':'0.8', 'percentileTop':'99.60000000000001', 'probThresh':'0.45', 'nmsThresh':'0.05', 'outputType':'ROI Manager', 'nTiles':'1', 'excludeBoundary':'2', 'roiPosition':'Automatic', 'verbose':'false', 'showCsbdeepProgress':'false', 'showProbAndDist':'false'], process=[false]");  //REMEMBER TO CHANGE SETTNINGS FOR THIS PROTOCOL FUCK - run stardist
	    newImage("HyperStack", "16-bit grayscale-mode", pixelheight, pixelheight, 1, 1, 1); //Create black square of the same proportions as FOV
	    selectImage("HyperStack"); //select hyperstack
	    roiManager("Fill");  //Fill based on ROI manager of stardist output
	    selectImage("HyperStack"); //select hyperstack
	    run("Divide...", "value=65535"); //divide so cell conatining regions are 1, while non cell containging regions are 0
	    imageCalculator("Multiply create stack", "FOV_Number_"+(j+1)+"","HyperStack"); //Multiply to get intensity of only cell containing regions
	    selectImage("Result of FOV_Number_"+(j+1));
	    saveSettings();
	    setOption("Stack position", true);
	    Slice = nSlices;
	    for (n = 1; n <= nSlices; n++) {
	    	selectImage("Result of FOV_Number_"+(j+1));
	    	setSlice(n);
	    	run("Measure");
	    }
	    close("*");
	    roiManager("reset");
	    restoreSettings();
}
selectWindow("Results");
saveAs("Results", exfolder + File.separator + "Well_Averages" + File.separator + "Well_Number_"+(i+1) + ".csv");
close("*");
close("Results");
}


